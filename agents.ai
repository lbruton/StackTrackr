# StackTrackr Canonical Agent Instructions
**Version**: 4.2 - Comprehensive MCP Memory System Documentation  
**Created**: August 14, 2025  
**Updated**: August 15, 2025  
**Status**: Master Reference for All Agents

> **üö® CRITICAL**: All agents MUST check this file on initialization and before making any script/module changes

---

## üîÑ **MANDATORY INITIALIZATION CHECKLIST**

**Every agent MUST execute this complete checklist before any work:**

1. ‚úÖ **Git Status Check**: Run `git status` and report any uncommitted changes
2. ‚úÖ **Create Git Checkpoint**: Always create checkpoint before starting work
3. ‚úÖ **Read Complete Instructions**: Review this file (`/agents.ai`) completely  
4. ‚úÖ **Check MCP Memory**: Query memory for relevant context and past solutions
5. ‚úÖ **Review Roadmap**: Check `/docs/roadmap.md` for assigned tasks and priorities
6. ‚úÖ **Document Starting Point**: Log initial status in your agent memory file
7. ‚úÖ **Validate Dependencies**: Reference script loading order before any file modifications

---

## üõ†Ô∏è **ENHANCED GIT PROTOCOL**

### **Pre-Work Requirements**
```bash
# 1. ALWAYS check status first
git status

# 2. MANDATORY checkpoint before any changes
git add -A
git commit -m "Checkpoint before [task description]"

# 3. Note current commit hash for rollback reference
git log --oneline -1
```

### **During Work Requirements**
- **Incremental Commits**: For tasks >30 minutes, commit progress every 15-20 minutes
- **Descriptive Messages**: Use conventional commits (feat:, fix:, docs:, refactor:)
- **Atomic Changes**: Each commit should represent one logical change

### **Post-Work Requirements**
```bash
# 1. Final commit with clear description
git add -A
git commit -m "feat: [complete description of changes]"

# 2. Update version and document changes
# (handled by agent workflow)

# 3. Create completion tag if major feature
git tag -a "v[version]" -m "[description]"
```

### **Emergency Rollback Protocol**
```bash
# Rollback to last checkpoint
git reset --hard HEAD~1

# Rollback to specific commit
git reset --hard [commit-hash]

# Create recovery branch if needed
git checkout -b recovery-[timestamp]
```

---

## üìö **ENHANCED DOCUMENTATION PROTOCOL**

### **MANDATORY Documentation for ALL Changes**

#### **1. Agent Memory Updates** (Required for every session)
- **Start of session**: Log current task, phase, dependencies
- **During work**: Document decisions, challenges, solutions discovered
- **End of session**: Record completion status, handoff notes

#### **2. Code Documentation** (Required for all code changes)
- **Function Changes**: Update JSDoc comments for modified functions
- **New Features**: Add comprehensive comments explaining logic
- **Complex Logic**: Include inline comments for future maintainers
- **Dependencies**: Document any new requirements or breaking changes

#### **3. Project Documentation** (Required for significant changes)
- **Patch Files**: Create in `/docs/patch/` for every version bump
- **Fix Documentation**: Add to `/docs/fixes/` for all bug resolutions  
- **Architecture Changes**: Update relevant guides in `/docs/`
- **Breaking Changes**: Document in changelog and upgrade notes

#### **4. Decision Documentation** (Required for architectural decisions)
- **Why**: Record reasoning behind implementation choices
- **Alternatives**: Note other options considered and why rejected
- **Trade-offs**: Document performance, maintainability, or complexity impacts
- **Future Considerations**: Note potential improvements or known limitations

---

## üß† **COMPREHENSIVE MCP MEMORY SYSTEM**

### **üîç Memory System Overview**
StackTrackr uses a sophisticated multi-layer memory system for agent coordination:

1. **MCP Memory Graph** - Live, shared memory across all agents and projects
2. **Local Memory JSON** - Project-specific tasks, bugs, and context
3. **Agent Memory Files** - Individual agent status and learnings
4. **GitHub Memory Sync** - Cross-project coordination with rEngine ecosystem

### **üöÄ MANDATORY Memory Protocol - ALL AGENTS MUST FOLLOW**

#### **Session Initialization (REQUIRED)**
```bash
# 1. ALWAYS start by reading the memory graph
mcp_memory_read_graph

# 2. Search for relevant context
mcp_memory_search_nodes "StackTrackr bugs"
mcp_memory_search_nodes "current task"
mcp_memory_search_nodes "[your specific task area]"

# 3. Check local memory for detailed context
# Read local_memory.json for tasks, bugs, features
```

#### **During Work (REQUIRED)**
```bash
# Document new discoveries immediately
mcp_memory_add_observations
- entityName: "StackTrackr"
- contents: ["New bug found: [description]", "Solution: [approach]"]

# Create new entities for major discoveries
mcp_memory_create_entities
- name: "Bug-[ID]" 
- entityType: "Bug Report"
- observations: ["Description", "Root cause", "Solution"]
```

#### **Session Completion (REQUIRED)**
```bash
# Update your progress and learnings
mcp_memory_add_observations
- entityName: "Central Memory Manager"
- contents: ["Agent [name] completed [task]", "Key learnings: [details]"]

# Document handoff information
mcp_memory_create_entities
- name: "Handoff-[timestamp]"
- entityType: "Agent Coordination" 
- observations: ["Status", "Next steps", "Blockers"]
```

### **üîß Memory Tools - Complete Reference**

#### **mcp_memory_read_graph** - START HERE ALWAYS
```
Purpose: Get complete project memory state
Usage: Run at session start to understand full context
Returns: All entities, relations, and project knowledge
```

#### **mcp_memory_search_nodes** - Find Relevant Context
```
Critical searches for StackTrackr work:
- "StackTrackr critical bugs" - Current critical issues
- "filter chips bug" - Known UI filtering issues  
- "fuzzy search" - Search algorithm problems
- "Numista integration" - API integration context
- "localStorage quota" - Storage limitation issues
- "mobile responsiveness" - Mobile UI problems
- "theme switching" - Theme system bugs
- "CSV import" - File processing issues

Example:
mcp_memory_search_nodes "filter chips styling bug"
```

#### **mcp_memory_create_entities** - Document New Discoveries
```
Required for:
- New bugs discovered
- Successful solutions implemented  
- Performance optimizations
- Integration patterns that work
- Critical dependencies identified

Example:
mcp_memory_create_entities([{
  "name": "Filter-Chips-Load-Bug",
  "entityType": "Bug Report", 
  "observations": [
    "Filter chips display wrong styling on page load",
    "Correct after user interaction with filters",
    "Root cause: CSS classes not applied during initial render",
    "Solution: Force filter chip refresh after DOM load"
  ]
}])
```

#### **mcp_memory_add_observations** - Continuous Learning
```
Add to existing entities:
- Code patterns that work well
- Common pitfalls encountered
- User feedback received
- Performance test results
- Browser compatibility notes

Example:
mcp_memory_add_observations([{
  "entityName": "StackTrackr",
  "contents": [
    "Mobile table rows need 2x height when width < 768px",
    "localStorage has 5-10MB limit, track usage carefully",
    "file:// protocol requires specific CSV parsing approach"
  ]
}])
```

#### **mcp_memory_open_nodes** - Deep Dive on Specific Items
```
Get complete details on:
- Specific bug reports
- Implementation patterns
- Previous solutions
- Architecture decisions

Example:
mcp_memory_open_nodes(["Filter-Chips-Load-Bug", "Fuzzy-Search-Algorithm"])
```

### **üéØ Memory Search Strategies**

#### **Before Starting Any Task**
```bash
# 1. Check for similar past work
mcp_memory_search_nodes "[task description]"

# 2. Look for related bugs  
mcp_memory_search_nodes "[component] bug"

# 3. Find implementation patterns
mcp_memory_search_nodes "[technology] implementation" 

# 4. Check for known limitations
mcp_memory_search_nodes "[area] limitations"
```

#### **When Encountering Bugs**
```bash
# 1. Check if bug is known
mcp_memory_search_nodes "[bug symptoms]"

# 2. Look for similar issues
mcp_memory_search_nodes "[component] similar problems"

# 3. Find past solutions
mcp_memory_search_nodes "[technology] fixes"
```

#### **For Feature Implementation**
```bash
# 1. Check existing patterns
mcp_memory_search_nodes "[feature type] implementation"

# 2. Find integration examples  
mcp_memory_search_nodes "[library] integration"

# 3. Look for performance considerations
mcp_memory_search_nodes "[feature] performance"
```

### **üìä Local Memory Integration**

#### **local_memory.json Structure**
```json
{
  "tasks": {
    "Critical Bugs": ["Sync time recording", "Sorting issues"],
    "Bug Fixes": ["Filter chips styling", "Fuzzy search precision"],
    "Feature Enhancements": ["Numista integration", "Mobile responsive"]
  },
  "bugs": [/* Detailed bug reports */],
  "solutions": [/* Implemented fixes */],
  "performance": [/* Optimization notes */]
}
```

#### **Sync with MCP Memory**
```bash
# Before major changes, sync local findings to MCP
# After implementing fixes, update both systems
# Document learnings in both local and MCP memory
```

### **ü§ù Agent Coordination Protocol**

#### **GPT Agents - Memory Access Issues**
If GPT agents report memory access problems:

1. **Check MCP Tools Availability**
   ```bash
   # Verify MCP memory tools are active
   mcp_memory_read_graph  # Should return full graph
   ```

2. **Fallback to Local Memory**
   ```bash
   # Read local_memory.json directly
   # Reference agents/memory file for backup
   # Use manual memory sync scripts
   ```

3. **Document Memory Access**
   ```bash
   # Always document which memory tools work
   # Report any access limitations found
   # Update agent coordination notes
   ```

#### **Cross-Agent Memory Sharing**
```bash
# When handing off between agents:
1. Update MCP memory with current status
2. Document specific blockers or learnings  
3. Note which tools/approaches worked
4. Identify any compatibility issues found
```

### **‚ö†Ô∏è CRITICAL: GPT AGENT MEMORY ACCESS PROTOCOL**

#### **For GPT Agents Unable to Access MCP Memory:**

**STEP 1: Verify Memory Tool Access**
```bash
# Test if MCP memory tools are available:
# Try: mcp_memory_read_graph
# If this fails, follow backup protocol below
```

**STEP 2: Use Local Memory Fallback**
```bash
# Read the local backup memory file:
# File: /agents/memory 
# Contains: Complete MCP memory graph in JSON format
# Parse for relevant entities and relations

# Also read local_memory.json for:
# - Current tasks and priorities
# - Known bugs and their status
# - Recent discoveries and solutions
```

**STEP 3: Document Memory Limitations**
```bash
# ALWAYS document in your agent file:
# - Which memory tools work/don't work
# - How you're accessing project context
# - Any coordination challenges faced
# 
# This helps other agents understand limitations
```

**STEP 4: Manual Memory Updates**
```bash
# If you can't use MCP tools:
# 1. Update local_memory.json directly
# 2. Add findings to your individual agent file  
# 3. Use Git commits to share discoveries
# 4. Leave clear handoff notes for next agent
```

**EXAMPLE: Reading Backup Memory**
```bash
# The /agents/memory file contains JSON lines like:
# {"type":"entity","name":"StackTrackr","observations":[...]}
# {"type":"entity","name":"Filter-Chips-Bug","observations":[...]}
# {"type":"relation","from":"StackTrackr","to":"Filter-Chips-Bug",...}
#
# Parse these to understand:
# - Current project state
# - Known issues and solutions  
# - Agent coordination status
```

**EXAMPLE: Updating Local Memory**
```json
// Add to local_memory.json:
{
  "agent_notes": {
    "gpt_limitations": "Cannot access MCP memory tools",
    "workaround": "Using local backup files",
    "last_sync": "2025-08-15",
    "coordination_method": "Git commits and agent files"
  }
}
```

#### **Memory Access Troubleshooting**

**If MCP Tools Fail:**
1. Check tool availability in current environment
2. Fall back to local_memory.json and agents/memory
3. Document the limitation clearly
4. Use Git for coordination with other agents

**If Local Files Missing:**
1. Check backups/ directory for recent exports
2. Look for .json files in scripts/ directory  
3. Check Git history for memory file changes
4. Create new memory entries manually if needed

**Essential Memory Items for StackTrackr:**
- Critical bugs: sync timing, sorting, filter chips
- Current features: Numista integration, mobile responsive
- Performance notes: localStorage limits, file:// protocol
- Architecture: script loading order, dependency chain
- Testing: browser compatibility, theme switching

### **üéØ STACKTRACKR-SPECIFIC MEMORY USAGE**

#### **Common Memory Queries for StackTrackr Work:**

**Bug Investigation:**
```bash
mcp_memory_search_nodes "filter chips display bug"
mcp_memory_search_nodes "fuzzy search Eagle results"  
mcp_memory_search_nodes "localStorage quota handling"
mcp_memory_search_nodes "sync time recording issue"
mcp_memory_search_nodes "unknown items sorting"
```

**Feature Development:**
```bash
mcp_memory_search_nodes "Numista modal integration"
mcp_memory_search_nodes "mobile table responsiveness"
mcp_memory_search_nodes "CSV import processing" 
mcp_memory_search_nodes "theme switching implementation"
mcp_memory_search_nodes "exponential backoff pattern"
```

**Performance Optimization:**
```bash
mcp_memory_search_nodes "localStorage performance"
mcp_memory_search_nodes "large dataset handling"
mcp_memory_search_nodes "Chart.js optimization"
mcp_memory_search_nodes "file protocol compatibility"
```

#### **Critical Memory Entities to Always Check:**

1. **StackTrackr** - Main project entity with core context
2. **Filter-Chips-Load-Bug** - Known styling issue on page load
3. **Fuzzy-Search-Algorithm** - Search precision improvements needed
4. **Mobile-Responsiveness** - Current mobile UI requirements
5. **LocalStorage-Management** - Storage quota and cleanup patterns
6. **Numista-Integration** - API integration status and patterns
7. **Theme-System** - Current theme implementation and issues

#### **Memory Update Templates:**

**For Bug Fixes:**
```bash
mcp_memory_create_entities([{
  "name": "Bug-[Short-Description]",
  "entityType": "Bug Report",
  "observations": [
    "Symptoms: [what user sees]",
    "Root cause: [technical cause]", 
    "Solution: [implementation approach]",
    "Files modified: [list of files]",
    "Testing: [how to verify fix]"
  ]
}])
```

**For Features:**
```bash
mcp_memory_create_entities([{
  "name": "Feature-[Name]",
  "entityType": "Feature Implementation",
  "observations": [
    "Requirements: [user needs]",
    "Approach: [technical solution]",
    "Dependencies: [libraries/files affected]", 
    "Performance impact: [considerations]",
    "Future improvements: [enhancement opportunities]"
  ]
}])
```

**For Performance Optimizations:**
```bash
mcp_memory_add_observations([{
  "entityName": "StackTrackr",
  "contents": [
    "Performance improvement: [description]",
    "Measurement: [before/after metrics]",
    "Implementation: [code changes made]",
    "Monitoring: [how to track ongoing performance]"
  ]
}])
```

---

### **Context7 Tools - Use for Documentation**

#### **mcp_context7_resolve-library-id** - Before using external libraries
```
Always resolve library documentation for:
- Chart.js features and best practices
- Papa Parse CSV handling
- jsPDF generation techniques
- JSZip compression methods
```

#### **mcp_context7_get-library-docs** - Implementation guidance
```
Get specific documentation for:
- Complex API usage patterns
- Performance optimization techniques
- Browser compatibility requirements
- Security best practices
```

### **Playwright Tools - Use for Testing**

#### **mcp_playwright_browser_navigate** - Test workflows
```
Test critical user paths:
- File import/export workflows
- Search and filtering functionality
- Theme switching and responsiveness
- Modal interactions and forms
```

#### **mcp_playwright_browser_snapshot** - Validate UI
```
Capture accessibility snapshots for:
- New feature implementations
- Layout changes and responsiveness
- Cross-browser compatibility
- Theme consistency validation
```

### **MCP Tool Decision Matrix**

| Task Type | Primary MCP Tools | Purpose |
|-----------|------------------|---------|
| Bug Investigation | memory_search_nodes | Find previous solutions |
| New Feature | context7_get-library-docs | Implementation guidance |
| Code Review | memory_add_observations | Document patterns |
| Testing | playwright_browser_* | Validate functionality |
| Architecture | memory_create_entities | Document decisions |

---

## üìã **ENHANCED TASK EXECUTION CHECKLIST**

### **Phase 1: Preparation** (MANDATORY)
- [ ] Git status check and checkpoint creation
- [ ] MCP memory query for relevant context
- [ ] Review related documentation and past solutions
- [ ] Validate understanding of requirements
- [ ] Document starting point in agent memory

### **Phase 2: Implementation** (MANDATORY)
- [ ] Follow existing code patterns and conventions
- [ ] Make incremental commits with descriptive messages
- [ ] Document decisions and reasoning inline
- [ ] Test changes incrementally
- [ ] Update relevant documentation as you go

### **Phase 3: Validation** (MANDATORY)
- [ ] Use Playwright tools for functional testing
- [ ] Verify compatibility with file:// protocol
- [ ] Test all three themes (dark/light/sepia)
- [ ] Validate mobile responsiveness
- [ ] Check browser compatibility

### **Phase 4: Documentation** (MANDATORY)
- [ ] Update JSDoc comments for modified functions
- [ ] Create patch file in `/docs/patch/`
- [ ] Document any fixes in `/docs/fixes/`
- [ ] Update agent memory with lessons learned
- [ ] Add MCP memory observations for future reference

### **Phase 5: Completion** (MANDATORY)
- [ ] Final git commit with complete description
- [ ] Bump version in `js/constants.js`
- [ ] Update `docs/changelog.md`
- [ ] Update `docs/functionstable.md` if applicable
- [ ] Create handoff notes for next agent if needed

---

## üéØ **PROJECT OVERVIEW**

**StackrTrackr** is a client-side precious metals inventory management web application:
- **Architecture**: Pure frontend, no server dependencies
- **Storage**: localStorage (5-10MB limit)
- **Libraries**: Chart.js, PapaParse, jsPDF, JSZip (CDN)
- **Styling**: CSS custom properties, responsive design
- **Version**: v3.04.73 (semantic: BRANCH.RELEASE.PATCH.state)
**‚ö†Ô∏è NEVER modify this order without updating ALL dependent files ‚ö†Ô∏è**
### Script Loading Sequence (from index.html):
1. **External Dependencies (CDN)**
   - `file-protocol-fix.js` ‚ö†Ô∏è MUST BE FIRST
   - PapaParse, jsPDF, Chart.js, JSZip

2. **Core Foundation** (Lines 2585-2590)
   ```
   debug-log.js ‚Üí constants.js ‚Üí state.js ‚Üí utils.js
   ```

3. **Feature Modules** (Lines 2591-2604)
   ```
   import-enhancements.js ‚Üí fuzzy-search.js ‚Üí autocomplete.js
   charts.js ‚Üí theme.js ‚Üí search.js ‚Üí filters.js ‚Üí sorting.js
   pagination.js ‚Üí detailsModal.js ‚Üí modals...
   ```

4. **Core Business Logic** (Lines 2605-2612)
   ```
   spot.js ‚Üí api.js ‚Üí catalog-*.js ‚Üí bulk-edit.js
   inventory.js ‚Üí about.js ‚Üí customMapping.js
   ```
   ```

6. **Application Startup** (Line 2616)
   ```
   init.js ‚Üê FINAL INITIALIZATION
   ```

### Function Export Requirements
**Critical functions that MUST be exported to global scope:**
- **inventory.js**: `importCsv`, `importJson`, `exportCsv`, `exportJson`, `exportPdf`, `updateSummary`, `toggleCollectable`
- **api.js**: `showFilesModal`, `hideFilesModal`, `fetchSpotPrice`
- **utils.js**: `checkFileSize`, `MAX_LOCAL_FILE_SIZE`
- **All modal handlers**: `show*Modal`, `hide*Modal`

### Export Pattern
  window.functionName = functionName;
}

### DOM Element Caching
```js
```js
## Documentation References (2025-08-14)

For all agents working in the StackTrackr workspace, the following documentation is required reading and should be referenced before any code changes:

- `/docs/js_module_reference.md`: Detailed JS module documentation
- `/docs/js_module_quick_reference.md`: Quick JS module summary
- `/docs/table_structure_and_styling.md`: Table structure, scripts, CSS pitfalls
- `/docs/modal_and_button_reference.md`: Modal and button design, functions
- `/docs/inventory_import_export_design.md`: Import/export, calculation, mapping logic

These documents are part of the MCP workspace context and must be kept up to date. Agents should validate all changes against these guides and update them as needed.
// Add new providers in constants.js
METALS_DEV: {
  name: "Metals.dev",
  baseUrl: "https://api.metals.dev/v1",
  endpoints: { ... },
  parseResponse: (data) => data.result,
}
```

### Modal Management
- Use standard open/close patterns from detailsModal.js
- Manage scrolling: `document.body.style.overflow = 'hidden'/'';`
- Clean up charts with ResizeObserver

---

## üö® **CRITICAL DEPENDENCY RULES**

1. **events.js depends on ALL modules above it**
2. **Functions must be available before events.js runs**
3. **Use `function` declarations for event handler functions (not `const`)**
4. **All modal functions must be exported before events.js**
5. **init.js must validate all dependencies before proceeding**

---

## üîç **DEBUGGING PROTOCOL**

### Before Making Changes
1. Check console for "inventory.js loaded completely"
2. Verify function exports: `typeof window.importCsv`
3. Confirm init.js dependency validation passes
4. Review existing error patterns

### Common Issues
- **Temporal Dead Zone**: `const` functions not available to event handlers
- **Missing Exports**: Functions not in global scope
- **Load Order**: Script dependencies not met
- **Modal Conflicts**: Multiple event listeners on same element

---

## üìÅ **FILE ORGANIZATION**

- `/js/`: Core application modules
- `/css/`: Theme and component styles  
- `/docs/`: Implementation guides and roadmap
- `/tests/`: Browser-based test files
- `/agents/`: Agent workflows and memory

---

## üõ†Ô∏è **DEVELOPMENT WORKFLOW**

### Adding New Features
1. ‚úÖ Check this file for loading order requirements
2. ‚úÖ Update constants.js for feature flags
3. ‚úÖ Create modular JS file in `/js/`
4. ‚úÖ Register DOM elements in state.js
5. ‚úÖ Wire up events in events.js (AFTER all dependencies)
6. ‚úÖ Initialize in init.js sequence
7. ‚úÖ Export required functions to global scope
8. ‚úÖ Update documentation

### Snapshot Requirement
**Before starting any project or making major changes, agents MUST create a workspace snapshot in the `/snapshots` folder.** This ensures a safe rollback point and preserves project history for debugging and audits.

### Testing Guidelines
- Test via file:// protocol or local server
- Verify localStorage quota (~5-10MB limit)
- Test all three themes (dark/light/sepia)
- Validate mobile responsive layouts
- Check function availability in console

---

## üîó **AGENT COORDINATION**

### Task Management
- Check `/agents/tasks/` for assignments
- Use git checkpoints before major changes
- Reference `/agents/unified-workflow.ai` for protocols
- Cross-reference `/docs/SCRIPT_LOADING_ORDER.md` for technical details

### Communication
- Report status using standard format from `unified-workflow.ai`
- Create handoff prompts for agent transitions
- Document changes in appropriate agent memory files

---

## Workflow File Integration

Agents MUST always check and follow the latest protocols in:
- `/agents/unified-workflow.ai` (primary source for task assignment, agent specialization, coordination, and efficiency rules)
- `/agents/workflow.ai` (quick delegation and agent role guide)

### Key Requirements:
- Follow auto-initialization, git checkpoint, and dependency management protocols from unified-workflow.ai
- Use trigger phrases and task assignment logic as defined
- Apply agent specialization and smart assignment rules
- Use the enhanced roadmap system for all task tracking
- Reference unified-workflow.ai for handoff, status reporting, and file naming conventions
- Always check for updates in these files before starting any new patch or task

**Agents should treat unified-workflow.ai as the canonical workflow reference for all StackTrackr development.**

---

## ‚ö° **QUICK REFERENCE**

**Before ANY script changes:**
1. ‚úÖ Reference script loading order above
2. ‚úÖ Check function export requirements  
3. ‚úÖ Verify dependencies are met
4. ‚úÖ Test function availability in global scope
5. ‚úÖ Use `function` declarations for event handlers

**Emergency Recovery:**
```sh
git reset --hard HEAD~1  # Rollback to last checkpoint
```

---

## File:// Compatibility Requirement

### Critical Requirement
All themes and features must maintain compatibility with the `file://` protocol. This includes:
- Ensuring SVGs render correctly without HTTP.
- Avoiding cross-origin issues with local file access.
- Testing all themes (dark, light, sepia) under `file://`.

### Implementation Guidelines
1. Use relative paths for assets.
2. Avoid Fetch API for local files; use alternative methods.
3. Explicitly set attributes like `fill`, `stroke`, and `height` for SVGs.
4. Validate compatibility during development and testing phases.

### Testing Checklist
- Verify SVG rendering in all themes.
- Test localStorage functionality under `file://`.
- Ensure no console errors related to cross-origin or access control.

### Documentation Update
Include this requirement in all relevant documentation and workflows.

---

## Inventory Table Application Map

### 1. Function Walkthrough
- **renderTable**: Main function for populating the table. Depends on:
  - formatPurchaseLocation
  - formatStorageLocation
  - filterLink
  - openNumistaModal
  - sanitizeHtml
  - getStorageLocationColor
  - getPurchaseLocationColor
  - escapeAttribute
- **formatPurchaseLocation / formatStorageLocation**: Format and truncate location fields, convert 'Numista Import'/'Unknown' to '‚Äî'.
- **filterLink**: Generates clickable filter chips for location columns.
- **openNumistaModal**: Handles modal/popup for Numista links, protocol-aware (file:// vs http(s)).
- **toggleCollectable**: Toggles collectable status, updates table and localStorage.
- **editItem / deleteItem**: Edit and delete inventory items, update table and localStorage.
- **sanitizeHtml / escapeAttribute**: Prevent XSS and attribute injection in table cells.
- **getStorageLocationColor / getPurchaseLocationColor**: Returns color for location chips.
- **updateSummary**: Updates summary table below inventory table.

### 2. CSS Class Map
- `.responsive-table`: Main table styling, width, border-collapse, font-size.
- `.icon-col`: Used for columns with icons (denomination, coinType, grading, condition).
- `.hidden`: Used for columns that are conditionally hidden (metadata columns).
- `.hover-effect`: Row hover styling.
- `.numista-modal-content`, `.modal-header`, `.nav-btn`, `.numista-nav-controls`: Modal and navigation controls styling.
- `.collectable-icon`, `.vault-icon`, `.bar-icon`: SVG icon styling for collectable status.
- `.catalog-link`, `.numista-text`, `.numista-empty`: Numista column styling.

### 3. DOM Handles & Elements
- `#inventoryTable`: Main table element.
- `#numistaModal`, `#numistaIframe`, `#numistaModalTitle`, `#numistaBackBtn`, `#numistaForwardBtn`, `#numistaCloseBtn`: Modal elements for Numista database.
- Table `<thead>` and `<tbody>`: Must not be removed or renamed.
- All `<td>` and `<th>` elements: Data-column attributes used for logic and styling.
- `.collectable-status`: Button for toggling collectable status.

### 4. Load Order Requirements
- **Critical**: JS modules must be loaded in the following order for table to function:
  1. file-protocol-fix.js
  2. constants.js
  3. utils.js
  4. state.js
  5. inventory.js
  6. numista-modal.js
  7. All other modules (detailsModal.js, sorting.js, pagination.js, etc.)
- **CSS**: styles.css must be loaded before any table rendering occurs.
- **HTML**: Table and modal elements must exist in DOM before JS runs renderTable or modal functions.

### 5. External Dependencies
- **Chart.js**: For summary and spot price charts (must be loaded after table).
- **PapaParse**: For CSV import/export (used by importCsv, importNumistaCsv).

### 6. File:// Protocol Compatibility
- All features, especially modals and SVGs, must work under file://. Avoid Fetch API for local files. Use relative paths for assets.
- Numista modal must open in a popup window under file://, not iframe.

### 7. Common Pitfalls
- Breaking load order will cause missing functions, undefined errors, or broken table rendering.
- Removing or renaming table/column IDs or classes will break JS and CSS logic.
- Changing CSS class names or removing required classes will break layout and design.
- Failing to test under file:// can cause modal and SVG issues.

### 8. Preservation Checklist
- [ ] JS load order validated
- [ ] CSS classes present and unchanged
- [ ] Table and modal DOM elements present
- [ ] All required functions available on window
- [ ] File:// compatibility tested
- [ ] Responsive design verified

### 9. Reference
See `docs/table-preservation-guide.md` for a full breakdown of table dependencies, preservation steps, and best practices.

---

**üìö See also:**
- `/docs/COMPLETE_FUNCTION_REFERENCE.md` - **COMPLETE FUNCTION INVENTORY & ARCHITECTURE MAP**
- `/agents/unified-workflow.ai` - Multi-agent coordination
- `/docs/SCRIPT_LOADING_ORDER.md` - Detailed technical reference
- `/agents/tasks/` - Current task assignments

---

## ÔøΩ **MCP WORKSPACE REFERENCES**

The MCP workspace now contains complete project knowledge:

### üóÇÔ∏è **Critical Objects Reference** (`/agents/critical_objects_reference.md`)
- **MUST READ**: A complete inventory of all critical global variables, functions, and constants.
- **Prevents common errors** like duplicate declarations and load order issues.
- **Outlines dependencies** and architectural patterns.

### üóÇÔ∏è **Function Inventory** (`/docs/COMPLETE_FUNCTION_REFERENCE.md`)
- **Complete function table** with parameters, returns, exports
- **Module dependency tree** showing relationships
- **Data flow architecture** diagrams
- **File structure map** with descriptions
- **Critical interaction patterns** and examples

### üèóÔ∏è **Architecture References**
- **Script loading order** (this file + detailed reference)
- **Global variable requirements** and localStorage keys
- **External dependency list** with purposes
- **Event handler patterns** and modal management
- **Data processing pipelines** and validation flows

### üìñ **Usage for Agents**
All MCP agents can now reference:
- Exact function signatures and purposes
- Module relationships and dependencies  
- Data flow patterns and architecture
- Critical global variables and storage keys
- Complete file organization and structure

---


## Multi-Agent Development Workflow (Sync from MULTI_AGENT_WORKFLOW.md.backup)

### Patch Workflow & Coordination
- Development proceeds via incremental v3.04.x patch releases, each designed for ~2 hour completion.
- Multiple agents work in parallel; coordination system prevents conflicts.
- Roadmap entries track assignments and progress.
- Before starting, pick a patch from roadmap, check dependencies, and announce your choice if coordinating.
- Always check for file conflicts, especially on high-risk files (index.html, events.js, css/styles.css).

### Patch Execution & Quality Standards
- Complete patch following quality standards:
  - Functional testing: empty/populated data, all user scenarios, mobile/desktop.
  - Integration testing: spot price, inventory, search, import/export, theme switching, modals.
  - Code quality: follow patterns, consistent naming, JSDoc for new functions, modular code.
  - Browser compatibility: Chrome, Firefox, Safari, Edge, file:// protocol, mobile browsers.
  - Documentation: update code comments, constants.js, planning notes, architectural decisions.
  - After patch: bump version, update all docs (functionstable.md, changelog.md, roadmap.md, status.md, structure.md).

### File Modification Guidelines
- High conflict risk: index.html, events.js, css/styles.css (coordinate carefully, minimal changes, document exactly what changed).
- Medium risk: api.js, inventory.js.
- Low risk: docs, modal HTML/CSS, utility functions, new modules.

### Patch Completion Checklist
- Before: read docs, understand patch, check dependencies, verify no conflicts, review code.
- During: follow patterns, minimal changes, incremental testing, document issues, keep changes organized.
- Before submit: functional/integration/code/browser/documentation/file cleanup.
- After: bump version, mark patch complete, document findings, note requirement changes, archive previous build and link back to root.

### Technical Context
- Client-side only, modular JS, localStorage, responsive CSS, external libs (Chart.js, PapaParse, XLSX, jsPDF, JSZip).
- Key data: inventory, spotPrices, spotHistory, apiConfig, elements.
- Constants: APP_VERSION, METALS, storage keys, API providers.

### Debugging & Testing
- Open index.html directly (file://), import sample.csv, test workflows, edge cases, responsive design, theme switching.
- Watch for: localStorage quota, date parsing, XSS, mobile compatibility, file protocol differences.
- Performance: pagination, chart rendering, ZIP processing, search filtering.

### Communication Protocols
- Coordinate on high-risk files, bugs, shared components, architectural changes.
- Document deviations, performance/browser/security issues, dependencies, suggestions.
- Report issues in planning notes, document workarounds, flag breaking/API changes.

### Quick Reference
- docs/roadmap.md, docs/archive/notes/v3.2.0-planning-notes.md, docs/functionstable.md

---

## üß† **ENHANCED BUG PREVENTION & MEMORY INTEGRATION**

### **MANDATORY Bug Prevention Protocol**

#### **Before Making ANY Changes**
1. **Memory Search**: `mcp_memory_search_nodes` - Query for related bugs, issues, or patterns
2. **Fix Database Check**: Review `/docs/fixes/` for similar problems and solutions  
3. **Pattern Recognition**: Look for recurring issues in memory observations
4. **Solution Validation**: Ensure approach doesn't repeat documented mistakes

#### **When Bug Discovered**
1. **Immediate Memory Documentation**:
   ```
   Use: mcp_memory_create_entities
   Entity Type: "Bug"
   Name: "[Component]-[Issue-Type]-[Date]"
   Observations: [
     "Root Cause: [detailed cause analysis]",
     "Symptoms: [how bug manifests]", 
     "Solution: [step-by-step fix]",
     "Prevention: [how to avoid in future]",
     "Related Files: [affected components]"
   ]
   ```

2. **Local Backup**: Sync with `local_memory.json` using `json_memory_sync.py`

3. **Fix Documentation**: Create detailed fix file in `/docs/fixes/BUG-[number].md`

4. **Roadmap Integration**: Add to roadmap if user-facing or critical

#### **Testing Against Known Issues**
1. **Comprehensive Memory Query**:
   ```
   Patterns to search:
   - "[component-name] bug OR [component-name] issue"
   - "[error-message]" (exact error text)
   - "[technology] problem OR [technology] pitfall" 
   - "file protocol issue OR localhost issue"
   ```

2. **Apply Historical Solutions**: Use `mcp_memory_open_nodes` to get full context

3. **Validate Root Cause Fix**: Ensure solution addresses cause, not just symptoms

### **Continuous Learning Protocol**

#### **During Development**
```
Use: mcp_memory_add_observations regularly for:
- Code patterns that work reliably
- Common pitfalls and how to avoid them  
- Performance considerations and trade-offs
- Browser compatibility discoveries
- File protocol specific requirements
```

#### **Knowledge Sharing Between Agents**
```
Memory entities should include:
- "Agent": [which agent discovered this]
- "Context": [what task they were working on]
- "Confidence": [how reliable is this solution]
- "Last Tested": [when was this last validated]
```

### **Quality Assurance Through Memory**

Before completing any task, agents MUST:
1. **Search for Quality Issues**: `mcp_memory_search_nodes` with component names
2. **Apply Lessons Learned**: Review observations from past agents  
3. **Document New Discoveries**: `mcp_memory_add_observations` for future reference
4. **Cross-Reference Fix Database**: Ensure solution doesn't conflict with known fixes

This creates a self-improving system where each agent builds on the knowledge of previous agents, preventing repeated mistakes and continuously improving code quality.

---

## Agent Memory & Status Files

Each agent model MUST maintain its own individual memory/status file in `/agents/`:
- `gpt.ai`, `gpt-4o.ai`, `gpt-4-1.ai`, `gpt-5.ai` for GPT models
- `claude.ai`, `claude-haiku.ai`, `claude-sonnet.ai`, `claude-opus.ai` for Claude models
- `gemini.ai`, `gemini-pro.ai` for Gemini models

### Usage Instructions:
- Update your personal file at the start and end of each session.
- Record current status, last task, phase, dependencies, and handoff context.
- Reference your personal file for resuming work or reporting status.
- Main `agents.ai` should reference these files for model-specific coordination and status tracking.

**This allows multiple models to work on different tasks in parallel, with clear separation and coordination.**

---

## Basic Trigger Words for Agent Actions

After reading the ai file, agents should listen for these trigger words to initiate common actions:

- **"status"**: Report current status and last task, and update your individual .ai file with the latest status information
- **"start"**: Begin assigned task
- **"next"**: Move to the next step or phase
- **"pause"**: Pause work and await further instructions
- **"handoff"**: Prepare context for another agent
- **"rollback"**: Revert to last git checkpoint
- **"summary"**: Provide a summary of work completed
- **"dependencies"**: List current dependencies or blocking issues
- **"update"**: Refresh status or memory file
- **"complete"**: Mark task as finished and update docs
- **"checkpoint"**: Create a git checkpoint (commit current changes with a descriptive message)
- **"cleanup"**: Move all documentation files to the `docs` folder, all test files to the `tests` folder, and remove any unused or obsolete files from the workspace

Agents should respond to these trigger words with the appropriate action or prompt for further clarification if needed.

---

## Agent Change Log Requirement
For every major change that touches a script or DOM object, agents MUST write a short, concise entry to a running change log in their individual `.ai` file. Each entry should include:
- What was changed
- Why the change was made
- Any relevant context or reasoning

This log supports traceability, debugging, and review of agent decisions and logic.

## PATCH File Requirement
For every major change, agents MUST create a PATCH file in the docs/patch/ directory. The PATCH file must:
1. Use the semantic version that was bumped (e.g., PATCH-3.04.74.ai)
2. Include a summary of what was changed
3. Clearly attribute the change to the agent (use initials or a unique identifier)
4. Be committed alongside the code change

Example PATCH file format:
---
Version: 3.04.74
Date: 2025-08-14
Agent: GPT
Summary: Fixed table alignment and updated SVG rendering for file:// compatibility.
---

This ensures every change is traceable, versioned, and attributed to the responsible agent.

## Documentation File Naming Convention
All documentation intended for agent use must use the `.ai` extension (e.g., `agents.ai`, `references.ai`).
All documentation intended for human (owner/maintainer) use must use the `.md` extension (e.g., `README.md`, `roadmap.md`).
This ensures clear separation and easy identification of agent vs. human documentation throughout the project.

## Fix Documentation Protocol
Anytime a fix is found and implemented, agents MUST:
1. Before attempting a new fix, check the `docs/fixes/` folder for similar issues and solutions.
2. Document the fix in their change log and in a dedicated fix file.
3. Add a fix file to the `docs/fixes/` folder, describing the problem, solution, and any relevant code or context.
4. Reference the fix file in future work to avoid redundant solutions.

This creates a searchable database of fixes and ensures solutions are not reinvented repeatedly.

---

## Agent Initialization Confirmation Protocol
On startup, every agent MUST:
1. Confirm (in chat or log) that they have read and understood the latest agents.ai file.
2. Prompt the user: "I have loaded the latest agent protocols. What would you like to do next?"
3. Await explicit user instruction before proceeding with any initialization or actions.

This ensures agents are always up-to-date and user-driven before taking any action.

---

## Agent Handoff Prompts
The `prompts` folder will contain any handoff prompts for special jobs between agents that may not be otherwise defined in the main workflow or task files. Agents should check this folder for custom instructions or coordination details when transitioning work or handling unique scenarios.

---

## Workspace Schema & Function Table Protocol
On startup, agents MUST:
1. Read the workspace schema/manifest file (e.g., `workspace-schema.json` or `file-manifest.md`) to understand the full file structure and dependencies.
2. Review the function table (e.g., `functionstable.md`) that describes every function and its purpose in the project.

This ensures agents have complete context of the workspace and available functions before taking any action.

---

# Reference to Application Structure

For a detailed overview of the application's folder structure, refer to the `structure.ai` file located in the `agents/` folder. This document is updated whenever the folder structure changes.
