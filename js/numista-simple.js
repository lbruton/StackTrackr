// Simple Numista CSV Import - Extensible Design
// This will replace the complex importNumistaCsv function

// Simple currency detection helper
const detectCurrency = (value) => {
  if (!value) return 'USD';
  const str = String(value).toLowerCase();
  if (str.includes('€') || str.includes('eur')) return 'EUR';
  if (str.includes('£') || str.includes('gbp')) return 'GBP';
  if (str.includes('¥') || str.includes('jpy')) return 'JPY';
  if (str.includes('$') || str.includes('usd')) return 'USD';
  return 'USD'; // Default
};

// Simple currency conversion (just return the value for now)
const convertToUsd = (amount, currency) => {
  // Future: Add real conversion rates
  // For now, just return the amount as-is
  return amount;
};

/**
 * Creates structured, parseable notes from CSV row data
 * @param {Object} row - The raw CSV row data
 * @param {Object} extracted - The extracted field data
 * @returns {string} Structured markdown notes
 */
const createStructuredNotes = (row, extracted) => {
  const noteLines = [];
  
  // Add header
  noteLines.push('## Import Data');
  noteLines.push('');
  
  // Core fields in specific order
  const coreFields = [
    { key: 'Title', label: 'Item Name' },
    { key: 'Public comment', label: 'Public Comment' },
    { key: 'Private comment', label: 'Private Comment' },
    { key: 'Description', label: 'Description' },
    { key: 'Collection', label: 'Collection' },
    { key: 'Country', label: 'Country' },
    { key: 'Period', label: 'Period' },
    { key: 'Year', label: 'Year' },
    { key: 'Denomination', label: 'Denomination' },
    { key: 'Currency', label: 'Currency' },
    { key: 'Mint', label: 'Mint' },
    { key: 'Mintage', label: 'Mintage' },
    { key: 'Shape', label: 'Shape' },
    { key: 'Alignment', label: 'Alignment' },
    { key: 'References', label: 'References' },
    { key: 'Date of acquisition', label: 'Date of Acquisition' },
    { key: 'Acquisition details', label: 'Acquisition Details' },
    { key: 'Grade', label: 'Grade' },
    { key: 'Comments', label: 'Comments' }
  ];
  
  // Add core fields that have values
  for (const field of coreFields) {
    const value = row[field.key];
    if (value && value.toString().trim() && value.toString().trim() !== '') {
      noteLines.push(`**${field.label}** - ${value.toString().trim()}`);
    }
  }
  
  // Add any other fields not in the core list
  const usedKeys = new Set(coreFields.map(f => f.key));
  usedKeys.add('N# number (with link)'); // Skip this as it goes to numistaId
  usedKeys.add('N# number'); // Skip variations
  usedKeys.add('Numista #'); 
  usedKeys.add('Buying price'); // Skip price fields as they go to price
  usedKeys.add('Average price');
  usedKeys.add('Purchase price');
  usedKeys.add('Quantity owned'); // Skip as it goes to qty
  usedKeys.add('Quantity');
  usedKeys.add('Weight'); // Skip as it goes to weight
  usedKeys.add('Mass');
  usedKeys.add('Composition'); // Skip as it goes to metal/composition
  
  const otherFields = [];
  for (const [key, value] of Object.entries(row)) {
    if (!usedKeys.has(key) && value && value.toString().trim() && value.toString().trim() !== '') {
      otherFields.push(`**${key}** - ${value.toString().trim()}`);
    }
  }
  
  if (otherFields.length > 0) {
    noteLines.push('');
    noteLines.push('### Additional Fields');
    noteLines.push('');
    noteLines.push(...otherFields);
  }
  
  // Add footer for re-parsing identification
  noteLines.push('');
  noteLines.push('---');
  noteLines.push('*Generated by StackrTrackr Numista Import*');
  
  return noteLines.join('\n');
};

/**
 * Advanced Numista price parser - handles dual price strategy
 * @param {Object} row - The CSV row data
 * @param {Object} profile - Field mapping profile
 * @returns {number} Parsed price in USD
 */
const parseNumistaPrice = (row, profile) => {
  // Configuration for dual price strategy
  const PRICE_CONFIG = {
    threshold: 0.3, // 30% difference threshold
    strategy: 'larger', // 'larger', 'average', or 'conservative'
    minPrice: 1.0 // Minimum price to consider valid
  };
  
  // Get the two main Numista price types
  const buyingPriceRaw = findFieldValue(row, [
    'Buying price', 'Purchase price', 'Price paid', 'Acquired for'
  ]);
  
  const averagePriceRaw = findFieldValue(row, [
    'Average price', 'Market price', 'Current price', 'Estimate', 'Value'
  ]);
  
  // Parse both prices
  const buyingPrice = parseComplexPrice(buyingPriceRaw);
  const averagePrice = parseComplexPrice(averagePriceRaw);
  
  const buy = buyingPrice.amount;
  const avg = averagePrice.amount;
  
  console.log(`💰 Dual price analysis:`, {
    buying: `${buyingPriceRaw} → $${buy}`,
    average: `${averagePriceRaw} → $${avg}`
  });
  
  // Strategy 1: Both prices available
  if (buy > PRICE_CONFIG.minPrice && avg > PRICE_CONFIG.minPrice) {
    const higher = Math.max(buy, avg);
    const lower = Math.min(buy, avg);
    const difference = (higher - lower) / lower;
    
    console.log(`📊 Price difference: ${(difference * 100).toFixed(1)}% (threshold: ${PRICE_CONFIG.threshold * 100}%)`);
    
    if (difference <= PRICE_CONFIG.threshold) {
      // Prices are close - use strategy
      switch (PRICE_CONFIG.strategy) {
        case 'larger':
          console.log(`✅ Using larger price: $${higher} (within threshold)`);
          return higher;
        case 'average':
          const avgResult = (buy + avg) / 2;
          console.log(`✅ Using average price: $${avgResult} (within threshold)`);
          return avgResult;
        case 'conservative':
          console.log(`✅ Using lower price: $${lower} (conservative approach)`);
          return lower;
      }
    } else {
      // Prices differ significantly - prefer buying price if available
      if (buy > PRICE_CONFIG.minPrice) {
        console.log(`⚠️ Large price difference (${(difference * 100).toFixed(1)}%), using buying price: $${buy}`);
        return buy;
      } else {
        console.log(`⚠️ Large price difference (${(difference * 100).toFixed(1)}%), using average price: $${avg}`);
        return avg;
      }
    }
  }
  
  // Strategy 2: Only one price available
  if (buy > PRICE_CONFIG.minPrice) {
    console.log(`✅ Using buying price only: $${buy}`);
    return buy;
  }
  
  if (avg > PRICE_CONFIG.minPrice) {
    console.log(`✅ Using average price only: $${avg}`);
    return avg;
  }
  
  // Strategy 3: Fallback to any price field
  console.log(`⚠️ No primary prices found, trying fallback fields...`);
  const fallbackFields = ['Price', 'Cost', 'Est. price'];
  
  for (const fieldName of fallbackFields) {
    const rawValue = findFieldValue(row, [fieldName]);
    if (!rawValue || rawValue.trim() === '') continue;
    
    const parsed = parseComplexPrice(rawValue);
    if (parsed.amount > 0) {
      console.log(`💰 Fallback price found in "${fieldName}": $${parsed.amount}`);
      return parsed.amount;
    }
  }
  
  console.log(`❌ No valid price found, using $0`);
  return 0;
};

/**
 * Parse complex price strings from Numista
 * @param {string} priceStr - Raw price string
 * @returns {Object} {amount: number, currency: string, notes: string}
 */
const parseComplexPrice = (priceStr) => {
  if (!priceStr || typeof priceStr !== 'string') {
    return { amount: 0, currency: 'USD', notes: 'No price data' };
  }
  
  const str = priceStr.trim();
  
  // Handle common "no price" indicators
  if (/^(n\/a|none|unknown|—|-|\.{3,})$/i.test(str)) {
    return { amount: 0, currency: 'USD', notes: 'No price available' };
  }
  
  // Detect currency
  const currency = detectCurrency(str);
  
  // Extract numbers from the string
  const numbers = str.match(/\d+(?:[.,]\d+)?/g);
  if (!numbers || numbers.length === 0) {
    return { amount: 0, currency, notes: 'No numeric value found' };
  }
  
  // Handle ranges: "15.00 - 25.00" → use average
  if (numbers.length >= 2 && /[-–—]/.test(str)) {
    const min = parseFloat(numbers[0].replace(',', '.'));
    const max = parseFloat(numbers[1].replace(',', '.'));
    const average = (min + max) / 2;
    const converted = convertToUsd(average, currency);
    return { 
      amount: converted, 
      currency, 
      notes: `Range ${min}-${max} ${currency}, using average` 
    };
  }
  
  // Single price: use the first (or only) number
  const amount = parseFloat(numbers[0].replace(',', '.'));
  const converted = convertToUsd(amount, currency);
  
  return { 
    amount: converted, 
    currency, 
    notes: `Single price: ${amount} ${currency}` 
  };
};

const importNumistaCsvSimple = (file, override = false) => {
  console.log('🚀 Starting Simplified Numista CSV import:', {
    fileName: file.name,
    override: override
  });

  try {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const csvText = e.target.result;
        
        // Simple, robust CSV parsing
        const results = Papa.parse(csvText, {
          header: true,
          skipEmptyLines: true,
          transform: function(value) {
            return value ? String(value).trim() : '';
          },
          error: function(error) {
            console.warn('CSV parsing error (continuing):', error);
          }
        });
        
        const rawTable = results.data;
        const imported = [];
        const skippedDetails = [];
        const totalRows = rawTable.length;
        
        console.log(`📊 Processing ${totalRows} Numista rows using profile-based mapping`);
        
        startImportProgress(totalRows);
        let processed = 0;
        let importedCount = 0;
        
        // Use the extensible field mapping system
        const profile = FIELD_MAPPING_PROFILES.numista;
        
        for (const row of rawTable) {
          processed++;
          
          // Extract fields using the mapping profile
          const extracted = extractFieldsUsingProfile(row, profile);
          
          // Simple data processing
          const name = extracted.name || 'Unknown Item';
          const composition = extracted.metal || 'Silver';
          const metal = parseNumistaMetal ? parseNumistaMetal(composition) : 'Silver';
          const weight = parseFloat(extracted.weight) || 0;
          const qty = parseInt(extracted.qty) || 1;
          // Use advanced Numista price parser
          const price = parseNumistaPrice(row, profile);
          const type = normalizeType ? normalizeType(extracted.type) : 'Coin';
          const numistaId = extracted.numistaId.replace(/[^\d]/g, '') || '';
          
          // Map Collection field to Storage Location
          const collection = row['Collection'] || '';
          const storageLocation = collection || extracted.storageLocation || '';
          
          // Create structured notes in parseable markdown format
          const structuredNotes = createStructuredNotes(row, extracted);
          
          // Create the inventory item  
          const item = sanitizeImportedItem({
            metal: metal,
            composition: composition,
            name: name,
            qty: qty,
            type: type,
            weight: weight,
            price: price,
            date: extracted.date || new Date().toISOString().split('T')[0],
            purchaseLocation: extracted.purchaseLocation || '',
            storageLocation: storageLocation,
            notes: structuredNotes,
            spotPriceAtPurchase: 0,
            premiumPerOz: 0,
            totalPremium: 0,
            isCollectable: true,
            numistaId: numistaId,
            serial: getNextSerial()
          });
          
          // Validate the item
          const validation = validateInventoryItem(item);
          if (validation.isValid) {
            imported.push(item);
            importedCount++;
            
            // Debug first few items
            if (importedCount <= 3) {
              console.log(`✅ Item ${importedCount} imported:`, {
                name: item.name,
                metal: item.metal,
                weight: item.weight,
                price: item.price
              });
            }
          } else {
            skippedDetails.push({
              line: processed,
              reason: validation.errors.join(', '),
              data: row
            });
            
            // Debug first few rejections
            if (skippedDetails.length <= 3) {
              console.log(`❌ Item ${processed} rejected:`, validation.errors);
            }
          }
          
          updateImportProgress(processed, importedCount, totalRows);
        }
        
        endImportProgress();
        
        // Show results
        if (skippedDetails.length > 0) {
          const skippedMessages = skippedDetails.map(s => 
            `Line ${s.line}: ${s.data.Title || s.data.Name || '[No Name]'} - ${s.reason}`
          );
          showImportResultsModal(imported.length, skippedMessages, totalRows);
        }
        
        if (imported.length === 0) {
          return errorHandler.showError('No items to import.');
        }
        
        // Add to inventory using existing global functions
        let inventory = [];
        const storageKey = window.LS_KEY || 'metalInventory'; // Fallback if LS_KEY not loaded
        
        try {
          inventory = JSON.parse(localStorage.getItem(storageKey) || '[]');
        } catch (e) {
          inventory = [];
        }
        
        console.log(`📦 Current inventory size: ${inventory.length}`);
        
        if (override) {
          inventory = imported;
          console.log(`🔄 Override mode: replacing with ${imported.length} new items`);
        } else {
          inventory = inventory.concat(imported);
          console.log(`🔄 Merge mode: adding ${imported.length} items to existing ${inventory.length - imported.length}`);
        }
        
        // Sync and save using global functions
        if (typeof catalogManager !== 'undefined' && catalogManager.syncInventory) {
          inventory = catalogManager.syncInventory(inventory);
          console.log(`🔄 Catalog sync completed`);
        }
        
        // Save to localStorage
        localStorage.setItem(storageKey, JSON.stringify(inventory));
        console.log(`💾 Saved ${inventory.length} items to localStorage`);
        
        // Trigger global inventory refresh events
        if (typeof window.dispatchEvent === 'function') {
          window.dispatchEvent(new CustomEvent('inventoryUpdated', { detail: { count: inventory.length } }));
        }
        
        // Update UI if functions are available
        if (typeof renderTable === 'function') {
          renderTable();
        }
        
        if (typeof updateStorageStats === 'function') {
          updateStorageStats();
        }
        
        console.log(`✅ Numista import completed: ${imported.length} items imported`);
        console.log(`📊 Final inventory size: ${inventory.length} total items`);
        console.log(`🔄 Table render function available: ${typeof renderTable === 'function'}`);
        
        // Force a manual table refresh
        if (typeof window.refreshInventoryDisplay === 'function') {
          window.refreshInventoryDisplay();
        }
        
        // Show success message
        if (typeof showToast === 'function') {
          showToast(`Successfully imported ${imported.length} items from Numista`, 'success');
        }
        
      } catch (error) {
        endImportProgress();
        errorHandler.handle(error, 'Numista CSV import');
      }
    };
    
    reader.onerror = (error) => {
      endImportProgress();
      errorHandler.handle(error, 'Numista CSV file reading');
    };
    
    reader.readAsText(file);
    
  } catch (error) {
    errorHandler.handle(error, 'Numista CSV import initialization');
  }
};

// Expose globally
window.importNumistaCsvSimple = importNumistaCsvSimple;