<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StackTrackr Performance Test - DOM Fragment vs String Rendering</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        .results {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .result-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #007acc;
        }
        .improvement {
            font-size: 1.2em;
            font-weight: bold;
            color: #28a745;
        }
        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #005a9e;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
        }
        .performance-data {
            font-family: monospace;
            background: #f8f8f8;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>StackTrackr Performance Test</h1>
        <p>This test compares the performance between the legacy string concatenation method and the new DOM Fragment approach for table rendering.</p>
        
        <div class="controls">
            <button onclick="runPerformanceTest()">Run Performance Test</button>
            <button onclick="toggleFeatureFlag()">Toggle DOM Fragment Feature</button>
            <button onclick="loadTestData()">Load Test Data (100 items)</button>
            <button onclick="clearData()">Clear Test Data</button>
        </div>
        
        <div id="status" class="status">
            <strong>Status:</strong> Ready to test
        </div>
        
        <div id="results" class="results" style="display: none;">
            <div class="result-card">
                <h3>Legacy String Method</h3>
                <div id="legacyTime">-</div>
                <div id="legacyDetails" class="performance-data"></div>
            </div>
            <div class="result-card">
                <h3>DOM Fragment Method</h3>
                <div id="fragmentTime">-</div>
                <div id="fragmentDetails" class="performance-data"></div>
            </div>
        </div>
        
        <div id="improvement" style="display: none;">
            <h3>Performance Improvement</h3>
            <div class="improvement" id="improvementPercent">-</div>
            <div id="improvementDetails" class="performance-data"></div>
        </div>
    </div>

    <!-- Include required scripts -->
    <script src="js/file-protocol-fix.js"></script>
    <script src="js/constants.js"></script>
    <script src="js/state.js"></script>
    <script src="js/utils.js"></script>
    <script src="js/inventory.js"></script>

    <script>
        let testResults = {};
        
        // Generate test data
        const generateTestData = (count = 100) => {
            const metals = ['Silver', 'Gold', 'Platinum', 'Palladium'];
            const types = ['Coin', 'Bar', 'Round', 'Bullion'];
            const items = [];
            
            for (let i = 0; i < count; i++) {
                const metal = metals[Math.floor(Math.random() * metals.length)];
                const type = types[Math.floor(Math.random() * types.length)];
                
                items.push({
                    metal: metal,
                    composition: metal,
                    name: `Test ${type} ${i + 1}`,
                    qty: Math.floor(Math.random() * 10) + 1,
                    type: type,
                    weight: Math.random() * 10 + 0.1,
                    price: Math.random() * 1000 + 10,
                    date: new Date(2020 + Math.random() * 4, Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toISOString().split('T')[0],
                    purchaseLocation: `Test Location ${i % 10}`,
                    storageLocation: `Storage ${i % 5}`,
                    notes: Math.random() > 0.7 ? `Test note ${i}` : '',
                    isCollectable: Math.random() > 0.8,
                    spotPriceAtPurchase: Math.random() * 100 + 10,
                    totalPremium: Math.random() * 50
                });
            }
            
            return items;
        };
        
        const loadTestData = () => {
            const testData = generateTestData(100);
            if (typeof window.inventory !== 'undefined') {
                window.inventory = testData;
                updateStatus('Loaded 100 test items into inventory');
                if (typeof window.renderTable === 'function') {
                    window.renderTable();
                }
            } else {
                updateStatus('Error: inventory not available');
            }
        };
        
        const clearData = () => {
            if (typeof window.inventory !== 'undefined') {
                window.inventory = [];
                updateStatus('Cleared all test data');
                if (typeof window.renderTable === 'function') {
                    window.renderTable();
                }
            }
        };
        
        const updateStatus = (message) => {
            document.getElementById('status').innerHTML = `<strong>Status:</strong> ${message}`;
        };
        
        const toggleFeatureFlag = () => {
            if (typeof window.featureFlags !== 'undefined') {
                const isEnabled = window.featureFlags.isEnabled('DOM_FRAGMENT_RENDERING');
                if (isEnabled) {
                    window.featureFlags.disable('DOM_FRAGMENT_RENDERING');
                    updateStatus('DOM Fragment rendering DISABLED - using legacy string method');
                } else {
                    window.featureFlags.enable('DOM_FRAGMENT_RENDERING');
                    updateStatus('DOM Fragment rendering ENABLED');
                }
            } else {
                updateStatus('Error: featureFlags not available');
            }
        };
        
        const measureRenderPerformance = (method, iterations = 5) => {
            const times = [];
            const startTime = performance.now();
            
            for (let i = 0; i < iterations; i++) {
                const iterStart = performance.now();
                if (typeof window.renderTable === 'function') {
                    window.renderTable();
                }
                const iterEnd = performance.now();
                times.push(iterEnd - iterStart);
            }
            
            const totalTime = performance.now() - startTime;
            const avgTime = times.reduce((a, b) => a + b, 0) / times.length;
            const minTime = Math.min(...times);
            const maxTime = Math.max(...times);
            
            return {
                method: method,
                totalTime: totalTime,
                avgTime: avgTime,
                minTime: minTime,
                maxTime: maxTime,
                iterations: iterations,
                times: times
            };
        };
        
        const runPerformanceTest = async () => {
            if (typeof window.inventory === 'undefined' || window.inventory.length === 0) {
                updateStatus('Please load test data first');
                return;
            }
            
            updateStatus('Running performance test...');
            
            // Test with DOM Fragment disabled (legacy method)
            if (typeof window.featureFlags !== 'undefined') {
                window.featureFlags.disable('DOM_FRAGMENT_RENDERING');
            }
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            const legacyResults = measureRenderPerformance('Legacy String Method', 10);
            
            // Test with DOM Fragment enabled
            if (typeof window.featureFlags !== 'undefined') {
                window.featureFlags.enable('DOM_FRAGMENT_RENDERING');
            }
            await new Promise(resolve => setTimeout(resolve, 100)); // Small delay
            const fragmentResults = measureRenderPerformance('DOM Fragment Method', 10);
            
            // Calculate improvement
            const improvement = ((legacyResults.avgTime - fragmentResults.avgTime) / legacyResults.avgTime) * 100;
            
            // Display results
            document.getElementById('legacyTime').textContent = `${legacyResults.avgTime.toFixed(2)}ms average`;
            document.getElementById('legacyDetails').textContent = 
                `Min: ${legacyResults.minTime.toFixed(2)}ms | Max: ${legacyResults.maxTime.toFixed(2)}ms | Total: ${legacyResults.totalTime.toFixed(2)}ms`;
            
            document.getElementById('fragmentTime').textContent = `${fragmentResults.avgTime.toFixed(2)}ms average`;
            document.getElementById('fragmentDetails').textContent = 
                `Min: ${fragmentResults.minTime.toFixed(2)}ms | Max: ${fragmentResults.maxTime.toFixed(2)}ms | Total: ${fragmentResults.totalTime.toFixed(2)}ms`;
            
            document.getElementById('improvementPercent').textContent = 
                improvement > 0 ? `${improvement.toFixed(1)}% faster` : `${Math.abs(improvement).toFixed(1)}% slower`;
            document.getElementById('improvementPercent').style.color = improvement > 0 ? '#28a745' : '#dc3545';
            
            document.getElementById('improvementDetails').textContent = 
                `DOM Fragment: ${fragmentResults.avgTime.toFixed(2)}ms vs Legacy: ${legacyResults.avgTime.toFixed(2)}ms`;
            
            document.getElementById('results').style.display = 'grid';
            document.getElementById('improvement').style.display = 'block';
            
            updateStatus(`Performance test completed. DOM Fragment method is ${improvement.toFixed(1)}% ${improvement > 0 ? 'faster' : 'slower'}`);
            
            // Store results for potential logging
            testResults = {
                legacy: legacyResults,
                fragment: fragmentResults,
                improvement: improvement,
                timestamp: new Date().toISOString()
            };
            
            console.log('Performance Test Results:', testResults);
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            updateStatus('Performance test ready. Load test data to begin.');
        });
    </script>
</body>
</html>
